<img width="112" height="39" alt="image" src="https://github.com/user-attachments/assets/058eefa0-abef-4072-a386-e3798fc8000b" /># Docker for Reproducible (AI) Research  
*A One-Hour Introduction*

**Thom Badings**  
Feb 12, 2026  
University of Oxford

---

## “But it works on my machine!”

Typical situation in research projects:

- Writing code for research projects
- Conda environment
- Python version (e.g. 3.12)
- Python packages (NumPy, Matplotlib, JAX, …)
- Other dependencies (C++ libraries, …)

You’re finished — how do you share with others?

- GitHub repository
- Installation instructions (many steps…)
- Different instructions depending on the OS, …

---

## What is Docker?

- A (free) tool to **package code + environment** into a single runnable unit
- Runs applications inside **containers** (isolated, lightweight environments)
- Same container runs **identically across machines**

### What problems does Docker solve?

- Let others run your code without complicated installation steps
- Dependency hell (conflicting Python, CUDA, library versions)
- Reproducibility over long time spans (months or years later)
- Easy archiving of code artifacts (often required by conferences)

---

## Docker vs. Virtual Machine

| Aspect | Virtual Machine (VM) | Docker |
|------|----------------------|--------|
| Operating system | Full operating system per VM | Uses the host OS kernel |
| Weight | Heavyweight | Lightweight |
| Isolation level | Hardware-level virtualization | Process-level isolation |
| Primary purpose | Designed to run different OS on single physical hardware | Designed to run applications in an isolated and reproducible environment |
| Resource allocation | Resources allocated up front | Resources used on demand |

---

## Docker Terminology

1. **Dockerfile**  
   File with instructions to create an image from

2. **Docker image**  
   Read-only (immutable) template used to create containers

3. **Docker container**  
   Runnable instance of an image

4. **Docker Hub**  
   Place to store, share, and manage container images

### Example Dockerfile

The following Docker file takes the Python 3.8 Docker image as its base, copies all the files (in the current working directory of the host), installs Python dependencies, and finally runs a command.

```
FROM python:3.8

# set a directory for the app
WORKDIR /usr/src/app

# copy all the files to the container
COPY . .

# install dependencies
RUN pip install --no-cache-dir -r requirements.txt

# define the port number the container should expose
EXPOSE 5000

# run the command
CMD ["python", "./app.py"]
```

---

## How I typically use Docker

During Python code development
- Develop locally (Conda environment)
- Store code on GitHub
- ReadMe with install instructions

Upon publication of a paper
- Source code on GitHub
- Create a Docker image with the precise code used to run experiments
- Archive this Docker image on Zenodo

---

## Install Docker

- Install Docker: https://docs.docker.com/get-started/get-docker/ 
- A simple tutorial: https://docker-curriculum.com/
- Do you see the following? Then, probably you didn’t start the Docker application

<img width="673" height="59" alt="image" src="https://github.com/user-attachments/assets/60622578-4b28-42c1-92c4-75e6fc895c13" />

### First steps with Docker
Let's explore Docker a little bit by running our first container:

```
docker run hello-world
```

This command pulls the `hello-world` image and creates a container for it. If correct, you see the output generated by the container (which is, not surprisingly, "Hello World").

Let's try a little bit more exciting example, and pull the `busybox` image:

```
docker pull busybox
```

We can check if the image was indeed downloaded, by showing all current images:

```
docker images
```

We can run the busybox image with:

```
Run busybox:
docker run busybox 
```

This doesn't do anything, because we did not give a command when running the container. Instead, let's now try:

```
docker run busybox echo "hello from busybox”
```

Which should indeed show the message we asked for. Still, notice that we still cannot really do something manually within the container. This is where the interactive mode is for:

```
docker run -it busybox sh
```

With the `-it` flag, notice that we really enter the container in the terminal, and can, for example, navigate folder and run anything we want. Within the docker container, every command is *local*: we can remove everything, exit the container, create it again, and everything’s back! We could even run `rm -rf bin` without any effect outside the container.

Containers are not automatically removed after running them. To show all containers, run:

```
docker ps -a
```

We can remove old containers with:

```
docker container prune
```

Or, by running `docker rm ...` with the ID of a specific container, which can be found via `docker ps -a`.

---

## Running web applications

I use the following template for my personal website: https://github.com/alshedivat/al-folio

<img width="612" height="368" alt="image" src="https://github.com/user-attachments/assets/ce91bb0c-c5f0-4bcd-8d6b-ac5dde22af77" />

This template can easily be deployed in a Docker container as follows. The first step is to clone the Git repository:

```
git clone https://github.com/alshedivat/al-folio.git
```

Next, run the Docker container:

```
docker compose pull
docker compose up
```

By default, this deploys the site locally at port 8080. To show the website, navigate to:

```
http://localhost:8080/al-folio/
```

What's nice is that changes are immediately deployed. Try it yourself: change the text in `_pages/about.md`, save the file, and refresh the website in the browser!
